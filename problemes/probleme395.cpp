#include "problemes.h"
#include "utilitaires.h"
#include "combinatoire.h"

typedef boost::multiprecision::cpp_int nombre;

namespace {
    struct noeud {
        noeud(long double x1_, long double y1_, long double x2_, long double y2_) :
                x1(x1_), y1(y1_), x2(x2_), y2(y2_) {}

        long double x1;
        long double y1;
        long double x2;
        long double y2;
    };
}

ENREGISTRER_PROBLEME(395, "Pythagorean tree") {
    // The Pythagorean tree is a fractal generated by the following procedure:
    //
    //Start with a unit square. Then, calling one of the sides its base (in the animation, the bottom side is the base):
    //
    //  1. Attach a right triangle to the side opposite the base, with the hypotenuse coinciding with that side and with
    //  the sides in a 3-4-5 ratio. Note that the smaller side of the triangle must be on the 'right' side with respect
    //  to the base (see animation).
    //  2. Attach a square to each leg of the right triangle, with one of its sides coinciding with that leg.
    //  3. Repeat this procedure for both squares, considering as their bases the sides touching the triangle.
    //
    // The resulting figure, after an infinite number of iterations, is the Pythagorean tree.
    //
    // p395_pythagorean.gif
    //
    // It can be shown that there exists at least one rectangle, whose sides are parallel to the largest square of the
    //
    // Pythagorean tree, which encloses the Pythagorean tree completely.
    //
    // Find the smallest area possible for such a bounding rectangle, and give your answer rounded to 10 decimal places.
    long double xMax = 1, yMax = 0, xMin = 0, yMin = -1;

    std::vector<noeud> noeuds;
    noeuds.emplace_back(0, 0, 1, 0);
    for (int i = 1; i < 100; ++i) {
        std::vector<noeud> suivants;
        for (auto x : noeuds) {
            xMax = std::max(xMax, std::max(x.x1, x.x2));
            xMin = std::min(xMin, std::min(x.x1, x.x2));
            yMax = std::max(yMax, std::max(x.y1, x.y2));
            yMin = std::min(yMin, std::min(x.y1, x.y2));

            long double dx = x.x2 - x.x1;
            long double dy = x.y2 - x.y1;

            if (xMin <= x.x1 + std::min(5 * dx, -5 * dx) + std::min(-5 * dy, 2 * dy) &&
                xMax >= x.x1 + std::max(5 * dx, -5 * dx) + std::max(-5 * dy, 2 * dy) &&
                yMin <= x.y1 + std::min(5 * dx, -2 * dx) + std::min(-5 * dy, 5 * dy) &&
                yMax >= x.y1 + std::max(5 * dx, -2 * dx) + std::max(-5 * dy, 5 * dy))
                continue;

            suivants.emplace_back(x.x1 - 0.48l * dx - 0.64l * dy, x.y1 + 0.64l * dx - 0.48l * dy,
                                  x.x1 + 0.16l * dx - 1.12l * dy, x.y1 + 1.12l * dx + 0.16l * dy);
            suivants.emplace_back(x.x1 + 1.12l * dx - 0.84l * dy, x.y1 + 0.84l * dx + 1.12l * dy,
                                  x.x1 + 1.48l * dx - 0.36l * dy, x.y1 + 0.36l * dx + 1.48l * dy);
        }

        std::swap(noeuds, suivants);

        std::cout << "nodes.size() = " << noeuds.size() << ", aire = "
                  << std::to_string((xMax - xMin) * (yMax - yMin), 10) << std::endl;
    }
    std::cout << "xMax = " << xMax << ", yMax = " << yMax << ", xMin = " << xMin << ", yMin = " << yMin << std::endl;

    long double aire = (xMax - xMin) * (yMax - yMin);
    return std::to_string(aire, 10);
}
